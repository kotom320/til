---

title: "TypeScript 제너릭(Generics) 정리"
date: "2025-08-21"
tags: ["TypeScript", "Generics"]
summary: "제너릭의 개념, T를 비롯한 타입 매개변수 사용 규칙, 제약(extends), 기본값, 추론과 활용 패턴을 정리합니다."
-----------------------------------------------------------------------------

## 1) 개요

제너릭은 **타입을 값처럼 매개변수화**하여 재사용성과 타입 안전성을 동시에 얻기 위한 문법이다. 함수·클래스·인터페이스·타입 별칭 어디에서나 사용 가능하다.

---

## 2) 핵심 개념

### 2.1 타입 매개변수 (T)

- `T`는 **Type**의 관례적인 이름. 한 글자로 간결히 쓰며, 의미가 필요한 경우 `TItem`, `TData`처럼 확장한다.
- 다중일 때는 관례적으로 `T, U, V` 또는 **역할 기반**으로 `K`(Key), `V`(Value), `E`(Element), `R`(Result), `P`(Props)를 사용한다.

```ts
function identity<T>(value: T): T {
  return value;
}
const a = identity<string>("hi"); // 명시
const b = identity(42); // 추론
```

### 2.2 제약 (extends)

- `extends`로 **허용 타입의 상한**을 지정해 사용 범위를 안전하게 제한한다.

```ts
function pluck<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map((k) => obj[k]);
}
```

### 2.3 기본 타입(defaults)

- 타입 매개변수에 기본값을 지정할 수 있다.

```ts
type ApiResult<T = unknown> = { ok: boolean; data: T };
```

### 2.4 타입 추론 (inference)

- 호출 시점의 인수로부터 `T`를 자동 추론한다. 명시가 필요할 때만 `<T>`를 붙인다.

```ts
function wrap<T>(value: T) {
  return { value };
}
const w = wrap({ id: 1 }); // T = { id: number }
```

### 2.5 인터페이스/타입, 클래스의 제너릭

```ts
interface Repository<T> {
  getById(id: string): Promise<T | null>;
  save(entity: T): Promise<void>;
}

class MemoryRepo<T extends { id: string }> implements Repository<T> {
  private store = new Map<string, T>();
  async getById(id: string) {
    return this.store.get(id) ?? null;
  }
  async save(entity: T) {
    this.store.set(entity.id, entity);
  }
}
```

### 2.6 유틸리티 타입과의 조합

- `Partial<T>`, `Required<T>`, `Readonly<T>`, `Record<K,V>`, `Pick<T,K>`, `Omit<T,K>` 등은 모두 제너릭 기반이다.

```ts
type Mutable<T> = { -readonly [K in keyof T]: T[K] };
```

---

## 3) 사용 패턴

### 3.1 API 함수 래퍼

```ts
async function getJson<T>(url: string): Promise<T> {
  const res = await fetch(url);
  if (!res.ok) throw new Error("HTTP " + res.status);
  return res.json() as Promise<T>;
}

// 사용
interface User {
  id: number;
  name: string;
}
const user = await getJson<User>("/api/user/1");
```

### 3.2 제약을 통한 안전한 속성 접근

```ts
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

### 3.3 React에서의 예시

```ts
// useState 제너릭 명시
const [value, setValue] = useState<number | null>(null);

// 제너릭 Props 컴포넌트
type ListProps<T> = { items: T[]; render: (item: T) => React.ReactNode };
function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>;
}
```

### 3.4 맵드 타입과 제너릭

```ts
type Nullable<T> = { [K in keyof T]: T[K] | null };
```

---

## 4) 네이밍 가이드

- **단일 타입**: `T`
- **키/값**: `K`, `V`
- **배열 요소**: `E`
- **함수 결과**: `R`
- **React 컴포넌트**: `TItem`, `TData`, `Props` 등 **의미 있는 접미사** 권장

---

## 5) 안티 패턴 & 주의점

- 불필요한 제너릭 남용: 실제로 정해진 한두 타입만 쓴다면 **유니온**이 더 단순하다.
- 너무 넓은 제약: `extends object`는 거의 무용. 필요한 형태로 구체화(`extends { id: string }`).
- `any`로 후퇴: 추론이 어렵다고 `any`를 넣으면 타입 안전성이 사라진다.
- **분리 원칙**: 제너릭 로직(타입 안전)과 데이터 정규화/검증 로직(zod 등)은 레이어를 분리한다.

---

## 6) 한눈에 보는 레시피

```ts
// 1) 기본
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}

// 2) 다중 타입 매개변수
function zip<T, U>(a: T[], b: U[]): Array<[T, U]> {
  return a.map((v, i) => [v, b[i]]);
}

// 3) 기본값 + 제약
interface Page<TItem = unknown> {
  items: TItem[];
  total: number;
}

// 4) keyof와 함께
function hasKey<T extends object, K extends PropertyKey>(
  o: T,
  k: K
): k is keyof T {
  return (k in o) as any;
}
```

---

## 7) 정리

- 제너릭은 **타입을 매개변수화**하여 재사용·안전성을 높인다.
- 핵심은 **제약(extends)과 추론**을 적절히 사용해 **필요한 만큼만 일반화**하는 것.
- 네이밍과 기본값을 통해 **읽기 좋은 API**를 설계한다.
